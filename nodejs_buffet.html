<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c0{background-color:#24292e;padding-top:0pt;padding-bottom:0pt;line-height:1.35;orphans:2;widows:2;text-align:left}.c1{color:#e1e4e8;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:15pt;font-family:"Courier New";font-style:normal}.c2{color:#6a737d;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:15pt;font-family:"Courier New";font-style:normal}.c11{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c6{font-size:15pt;font-family:"Courier New";color:#e1e4e8;font-weight:400}.c13{color:#000000;font-weight:400;font-size:11pt;font-family:"Arial"}.c9{font-size:15pt;font-family:"Courier New";color:#ffab70;font-weight:400}.c8{font-size:15pt;font-family:"Courier New";color:#b392f0;font-weight:400}.c3{font-size:15pt;font-family:"Courier New";color:#f97583;font-weight:400}.c7{font-size:15pt;font-family:"Courier New";color:#9ecbff;font-weight:400}.c5{font-size:15pt;font-family:"Courier New";color:#79b8ff;font-weight:400}.c12{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c10{text-decoration:none;vertical-align:baseline;font-style:normal}.c4{height:11pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c12"><p class="c0"><span class="c2">//FIRST CLASS FUNCTIONS</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">/* When functions can be treated like any other variable then those functions are first-class functions. There are many other programming languages, for example, scala, Haskell, etc which follow this including JS. Now because of this function can be passed as a param to another function(callback) or a function can return another function(higher-order function). map() and filter() are higher-order functions that are popularly used. */</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">//NODEJS</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">/* Node.js is a virtual machine that uses JavaScript as its scripting language and runs Chrome&rsquo;s V8 JavaScript engine.It is based on an event - driven architecture where I / O runs asynchronously making it lightweight and efficient.Node.js provides simplicity in development because of its non - blocking I / O and event - based model results in short response time and concurrent processing, unlike other frameworks where developers have to use thread management. It runs on a chrome v8 engine which is written in c++ and is highly performant with constant improvement. */</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">//NODEJS CONTROL FLOW</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">/* https://medium.com/@gunendu/control-flow-in-nodejs-8e855996a5c7 */</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">//TIMERS</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">/* setTimeout() can be used to schedule code execution after a designated amount of milliseconds. It accepts a function to execute as its first argument and the millisecond delay defined as a number as the second argument. Additional arguments may also be included and these will be passed on to the function. Here is an example of that: */</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c3">function</span><span class="c6">&nbsp;</span><span class="c8">myFunc</span><span class="c6">(</span><span class="c9">arg</span><span class="c1">) {</span></p><p class="c0"><span class="c6">&nbsp; &nbsp;console.</span><span class="c8">log</span><span class="c6">(</span><span class="c7">`arg was =&gt; ${</span><span class="c6">arg</span><span class="c7">}`</span><span class="c1">);</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c5">setTimeout</span><span class="c6">(myFunc, </span><span class="c5">1500</span><span class="c6">, </span><span class="c7">&#39;funky&#39;</span><span class="c1">);</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">/* The above function myFunc() will execute as close to 1500 milliseconds as possible due to the call of setTimeout(). The timeout interval that is set cannot be relied upon to execute after that exact number of milliseconds.This is because other executing code that blocks or holds onto the event loop will push the execution of the timeout back. The only guarantee is that the timeout will not execute sooner than the declared timeout interval. setTimeout() returns a Timeout object that can be used to reference the timeout that was set.This returned object can be used to cancel the timeout as well as change the execution behavior.</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">setImmediate() will execute code at the end of the current event loop cycle. This code will execute after any I/O operations in the current event loop and before any timers scheduled for the next event loop. This code execution could be thought of as happening &quot;right after this&quot;, meaning any code following the setImmediate() function call will execute before the setImmediate() function argument. The first argument to setImmediate() will be the function to execute. Any subsequent arguments will be passed to the function when it is executed. Here&#39;s an example: */</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c5">console</span><span class="c6">.</span><span class="c8">log</span><span class="c6">(</span><span class="c7">&#39;before immediate&#39;</span><span class="c1">);</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c8">setImmediate</span><span class="c6">((</span><span class="c9">arg</span><span class="c6">) </span><span class="c3">=&gt;</span><span class="c1">&nbsp;{</span></p><p class="c0"><span class="c6">&nbsp; &nbsp;</span><span class="c5">console</span><span class="c6">.</span><span class="c8">log</span><span class="c6">(</span><span class="c7">`executing immediate: ${</span><span class="c9">arg</span><span class="c7">}`</span><span class="c1">);</span></p><p class="c0"><span class="c6">}, </span><span class="c7">&#39;so immediate&#39;</span><span class="c1">);</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c5">console</span><span class="c6">.</span><span class="c8">log</span><span class="c6">(</span><span class="c7">&#39;after immediate&#39;</span><span class="c1">);</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">/* The above function passed to setImmediate() will execute after all runnable code has executed, and the console output will be:</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">before immediate</span></p><p class="c0"><span class="c2">after immediate</span></p><p class="c0"><span class="c2">executing immediate: so immediate</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">setImmediate() returns an Immediate object, which can be used to cancel the scheduled immediate.</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">If there is a block of code that should execute multiple times, setInterval() can be used to execute that code. setInterval() takes a function argument that will run an infinite number of times with a given millisecond delay as the second argument. Just like setTimeout(), additional arguments can be added beyond the delay, and these will be passed on to the function call. Also like setTimeout(), the delay cannot be guaranteed because of operations that may hold on to the event loop, and therefore should be treated as an approximate delay. See the below example: */</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c3">function</span><span class="c6">&nbsp;</span><span class="c8">intervalFunc</span><span class="c1">() {</span></p><p class="c0"><span class="c6">&nbsp; &nbsp;</span><span class="c5">console</span><span class="c6">.</span><span class="c8">log</span><span class="c6">(</span><span class="c7">&#39;Cant stop me now!&#39;</span><span class="c1">);</span></p><p class="c0"><span class="c1">}</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c5">setInterval</span><span class="c6">(</span><span class="c8">intervalFunc</span><span class="c6">, </span><span class="c5">1500</span><span class="c1">);</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">/* In the above example, intervalFunc() will execute about every 1500 milliseconds, or 1.5 seconds, until it is stopped. Just like setTimeout(), setInterval() also returns a Timeout object which can be used to reference and modify the interval that was set.</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">What can be done if a Timeout or Immediate object needs to be cancelled? setTimeout(), setImmediate(), and setInterval() return a timer object that can be used to reference the set Timeout or Immediate object. By passing said object into the respective clear function, execution of that object will be halted completely. The respective functions are clearTimeout(), clearImmediate(), and clearInterval(). See the example below for an example of each: */</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c3">const</span><span class="c6">&nbsp;</span><span class="c5">timeoutObj</span><span class="c6">&nbsp;</span><span class="c3">=</span><span class="c6">&nbsp;</span><span class="c5">setTimeout</span><span class="c6">(() </span><span class="c3">=&gt;</span><span class="c1">&nbsp;{</span></p><p class="c0"><span class="c6">&nbsp; &nbsp;</span><span class="c5">console</span><span class="c6">.</span><span class="c8">log</span><span class="c6">(</span><span class="c7">&#39;timeout beyond time&#39;</span><span class="c1">);</span></p><p class="c0"><span class="c6">}, </span><span class="c5">1500</span><span class="c1">);</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c3">const</span><span class="c6">&nbsp;</span><span class="c5">immediateObj</span><span class="c6">&nbsp;</span><span class="c3">=</span><span class="c6">&nbsp;</span><span class="c8">setImmediate</span><span class="c6">(() </span><span class="c3">=&gt;</span><span class="c1">&nbsp;{</span></p><p class="c0"><span class="c6">&nbsp; &nbsp;</span><span class="c5">console</span><span class="c6">.</span><span class="c8">log</span><span class="c6">(</span><span class="c7">&#39;immediately executing immediate&#39;</span><span class="c1">);</span></p><p class="c0"><span class="c1">});</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c3">const</span><span class="c6">&nbsp;</span><span class="c5">intervalObj</span><span class="c6">&nbsp;</span><span class="c3">=</span><span class="c6">&nbsp;</span><span class="c5">setInterval</span><span class="c6">(() </span><span class="c3">=&gt;</span><span class="c1">&nbsp;{</span></p><p class="c0"><span class="c6">&nbsp; &nbsp;</span><span class="c5">console</span><span class="c6">.</span><span class="c8">log</span><span class="c6">(</span><span class="c7">&#39;interviewing the interval&#39;</span><span class="c1">);</span></p><p class="c0"><span class="c6">}, </span><span class="c5">500</span><span class="c1">);</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c5">clearTimeout</span><span class="c6">(</span><span class="c5">timeoutObj</span><span class="c1">);</span></p><p class="c0"><span class="c8">clearImmediate</span><span class="c6">(</span><span class="c5">immediateObj</span><span class="c1">);</span></p><p class="c0"><span class="c5">clearInterval</span><span class="c6">(</span><span class="c5">intervalObj</span><span class="c1">);</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">//CHILD PROCESS</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">/* The spawn function launches a command in a new process and we can use it to pass that command any arguments. For example, here&rsquo;s code to spawn a new process that will execute the pwd command. */</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c3">const</span><span class="c6">&nbsp;{ </span><span class="c8">spawn</span><span class="c6">&nbsp;} </span><span class="c3">=</span><span class="c6">&nbsp;</span><span class="c8">require</span><span class="c6">(</span><span class="c7">&#39;child_process&#39;</span><span class="c1">);</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c3">const</span><span class="c6">&nbsp;</span><span class="c5">child</span><span class="c6">&nbsp;</span><span class="c3">=</span><span class="c6">&nbsp;</span><span class="c8">spawn</span><span class="c6">(</span><span class="c7">&#39;pwd&#39;</span><span class="c1">);</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">/* We simply destructure the spawn function out of the child_process module and execute it with the OS command as the first argument.</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">The fork function is a variation of the spawn function for spawning node processes. The biggest difference between spawn and fork is that a communication channel is established to the child process when using fork, so we can use the send function on the forked process along with the global process object itself to exchange messages between the parent and forked processes. We do this through the EventEmitter module interface. */</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">//API FUNCTIONS</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">/* There are two types of API functions: Asynchronous, non-blocking functions - mostly I/O operations which can be fork out of the main loop. Synchronous, blocking functions - mostly operations that influence the process running in the main loop. */</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">//ASYNC.QUEUE()</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">/* The async module is is designed for working with asynchronous JavaScript in NodeJS. The async.queue returns a queue object which is capable of concurrent processing i.e processing multiple items at a single time. Example: */</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c3">const</span><span class="c6">&nbsp;</span><span class="c5">queue</span><span class="c6">&nbsp;</span><span class="c3">=</span><span class="c6">&nbsp;async.</span><span class="c8">queue</span><span class="c6">((</span><span class="c9">task</span><span class="c6">, </span><span class="c9">completed</span><span class="c6">) </span><span class="c3">=&gt;</span><span class="c1">&nbsp;{</span></p><p class="c0"><span class="c6">&nbsp; &nbsp;</span><span class="c2">/* Here task is the current element being</span></p><p class="c0"><span class="c2">&nbsp; &nbsp;processed and completed is the callback function */</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c6">&nbsp; &nbsp;</span><span class="c5">console</span><span class="c6">.</span><span class="c8">log</span><span class="c6">(</span><span class="c7">&quot;Currently Busy Processing Task &quot;</span><span class="c6">&nbsp;</span><span class="c3">+</span><span class="c6">&nbsp;</span><span class="c9">task</span><span class="c1">);</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c6">&nbsp; &nbsp;</span><span class="c2">// Simulating a complex process.</span></p><p class="c0"><span class="c6">&nbsp; &nbsp;</span><span class="c5">setTimeout</span><span class="c6">(() </span><span class="c3">=&gt;</span><span class="c1">&nbsp;{</span></p><p class="c0"><span class="c6">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c5 c10">3</span></p><p class="c0"><span class="c6">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c2">// Number of elements to be processed.</span></p><p class="c0"><span class="c6">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3">const</span><span class="c6">&nbsp;</span><span class="c5">remaining</span><span class="c6">&nbsp;</span><span class="c3">=</span><span class="c6">&nbsp;</span><span class="c5">queue</span><span class="c6">.</span><span class="c8">length</span><span class="c1">();</span></p><p class="c0"><span class="c6">&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c8">completed</span><span class="c6">(</span><span class="c5">null</span><span class="c1">, { task, remaining });</span></p><p class="c0"><span class="c6">&nbsp; &nbsp;}, </span><span class="c5">1000</span><span class="c1">);</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c6">}, </span><span class="c5">1</span><span class="c1">);</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">/* The concurrency value is set to one,</span></p><p class="c0"><span class="c2">Which means that one element is being</span></p><p class="c0"><span class="c2">Processed at a particular time */</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">//EVENT LOOP</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">/* https://www.geeksforgeeks.org/node-js-event-loop/</span></p><p class="c0"><span class="c2">The main loop is single-threaded and all async calls are managed by libuv library. This is because libuv sets up a thread pool to handle such concurrency. How many threads will be there in the thread pool depends upon the number of cores but you can override this. */</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">//nextTick()</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">/* Every time the event loop takes a full trip, we call it a tick. When we pass a function to process.nextTick(), we instruct the engine to invoke this function at the end of the current operation, before the next event loop tick starts: */</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c6">process.</span><span class="c8">nextTick</span><span class="c6">(() </span><span class="c3">=&gt;</span><span class="c1">&nbsp;{</span></p><p class="c0"><span class="c6">&nbsp; &nbsp;</span><span class="c2">//do something</span></p><p class="c0"><span class="c1">})</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">/* The event loop is busy processing the current function code. When this operation ends, the JS engine runs all the functions passed to nextTick calls during that operation. It&#39;s the way we can tell the JS engine to process a function asynchronously (after the current function), but as soon as possible, not queue it. Calling setTimeout(() =&gt; {}, 0) will execute the function at the end of next tick, much later than when using nextTick() which prioritizes the call and executes it just before the beginning of the next tick. Use nextTick() when you want to make sure that in the next event loop iteration that code is already executed. */</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">//ASYNC AWAIT</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">/* https://nodejs.dev/learn/modern-asynchronous-javascript-with-async-and-await */</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">//EventEmitter</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">/* the interaction of the user is handled through events: mouse clicks, keyboard button presses, reacting to mouse movements, and so on. On the backend side, Node.js offers us the option to build a similar system using the events module. This module, in particular, offers the EventEmitter class, which we&#39;ll use to handle our events.</span></p><p class="c0"><span class="c2">const EventEmitter = require(&#39;events&#39;)</span></p><p class="c0"><span class="c2">const eventEmitter = new EventEmitter()</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">This object exposes, among many others, the on and emit methods.</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">emit is used to trigger an event</span></p><p class="c0"><span class="c2">on is used to add a callback function that&#39;s going to be executed when the event is triggered</span></p><p class="c0"><span class="c2">For example, let&#39;s create a start event, and as a matter of providing a sample, we react to that by just logging to the console: */</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c6">eventEmitter.</span><span class="c8">on</span><span class="c6">(</span><span class="c7">&#39;start&#39;</span><span class="c6">, </span><span class="c9">number</span><span class="c6">&nbsp;</span><span class="c3">=&gt;</span><span class="c1">&nbsp;{</span></p><p class="c0"><span class="c6">&nbsp; &nbsp;</span><span class="c5">console</span><span class="c6">.</span><span class="c8">log</span><span class="c6">(</span><span class="c7">`started ${</span><span class="c9">number</span><span class="c7">}`</span><span class="c1">)</span></p><p class="c0"><span class="c1">});</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c6">eventEmitter.</span><span class="c8">emit</span><span class="c6">(</span><span class="c7">&#39;start&#39;</span><span class="c6">, </span><span class="c5">23</span><span class="c1">);</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">/* the event handler function is triggered, and we get the console log. The EventEmitter object also exposes several other methods to interact with events, like</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">once(): add a one-time listener</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">removeListener() / off(): remove an event listener from an event</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">removeAllListeners(): remove all listeners for an event */</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">//STREAM</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">/* https://nodejs.dev/learn/nodejs-streams */</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">//BUFFERS</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">/* https://nodejs.dev/learn/nodejs-buffers */</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">//MIDDLEWARE</span></p><p class="c0 c4"><span class="c1"></span></p><p class="c0"><span class="c2">/* Middleware comes in between your request and business logic. It is mainly used to capture logs and enable rate limit, routing, authentication, basically whatever that is not a part of business logic. There are third-party middleware also such as body-parser and you can write your own middleware for a specific use case. */</span></p><p class="c4 c11"><span class="c10 c13"></span></p></body></html>